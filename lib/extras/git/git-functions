# git functions

# Just some local things Mike uses (release early, release often)
#
# Worth a look:
#
# - git-repos: List all git repos (remote_url and git_dir)
# - git-tarball-create: Creates a tarball based on a pecial gitignore file

git-repos() {

    local search_dir="${1:-.}" # Use provided directory or default to current directory if not provided

    # Find all .git directories under the specified directory
    find "$search_dir" -type d -name .git 2>/dev/null | while read -r git_dir; do
        local repo_dir
        repo_dir=$(dirname "$git_dir") # Get the repository directory by removing the .git part
        local repo_url
        repo_url=$(git -C "$repo_dir" config --get remote.origin.url) # Get the repository's remote URL
        printf "%s\t%s\n" "$repo_url" "${repo_dir}" # Print the repository URL and directory path, separated by a tab
    done \
    | sort -k1,1 \
    | bma columnise
}

git-ls-noticed() {

    # git-ls-included - List files from git index that not ignored by specified gitignore file.
    #
    # Usage: git-ls-noticed <gitignore_file>

    local gitignore_file="${1:-}"

    if [[ -z $gitignore_file ]]; then
        echo "Usage: git-ls-included <gitignore_file>" >&2
        return 1
    elif [[ ! -f $gitignore_file ]]; then
        echo "Error: File '$gitignore_file' not found." >&2
        return 1
    fi
    gitignore_file="$(realpath "$gitignore_file")"
    local git_repo_path="$(git rev-parse --show-toplevel)"

    (
        cd "${git_repo_path}" || exit
        # Use git to list files for inclusion in the tarball
        git ls-files --exclude-from="$gitignore_file"
          # --cached # include uncommitted changes from git staging are
          # --others # include untracked files
    )
}

git-tarball-create() {

    # git-tarball-create - Creates a tarball based on a single gitignore file
    #
    # Usage: git-tarball-create <gitignore_file>
    #

    local gitignore="${1:-}"

    # Verify gitignore_file argument is provided
    if [[ -z $gitignore_file ]]; then
        echo "Usage: tarball-create <gitignore_file>" >&2
        return 1
    elif [[ ! -f $gitignore_file ]]; then
        # Verify gitignore_file file exists
        echo "Error: gitignore_file file '$gitignore_file' not found." >&2
        return 1
    fi

    local last_commit_date="$(git log -1 --format=%cd --date=format:%Y-%m-%d)"
    local git_repo_path="$(git rev-parse --show-toplevel)"
    local git_repo_name="${git_repo_path##*/}"
    local variant="$(basename "${gitignore_file}")"
    local release="${git_repo_name}-${variant}-${last_commit_date}"
    local build_dir="build"
    local tarball="${build_dir}/${release}.tar.gz"

    (
        cd "${git_repo_path}" || exit
        # Ensure the build directory exists
        mkdir -p "$build_dir" || { echo "Failed to create build directory: $build_dir" >&2; return 1; }

        # Use git to list files for inclusion in the tarball
        if ! git-ls-included "$gitignore_file" \
        | tar --transform "s,^,${release}/," -czf "${tarball}" -T -
        then 
            echo "Error: Failed to create tarball." >&2
            return 1
        fi
    )

    echo "Tarball created: ${tarball}"
}


git-repo-dirs(){

    # list dirs under a path that contain git repos

    local search_dir="${1:-~/git}" # Use provided directory or default to current directory if not provided

    git-repos "${search_dir}" | cut -f2 | xargs dirname | sort -u | rg -v .old | sed "s#$search_dir/##"
}

git-repos-save() {
    (
        cd ~/.mt/git
        for dir in $(git-repo-dirs ~/git); do
            echo $dir
            mkdir -p $dir
            git-repos ~/git/$dir | tee $dir/git-repos.txt
        done
    )
}

git-repo-create() {
    local repo_name=$(basename "$1" .git) # Ensures repo_name is derived cleanly

    # Prevent cloning into the same repository directory
    if [ -d "$repo_name.git" ]; then
        echo "A directory named '$repo_name.git' already exists. Exiting to avoid conflict."
        return 1
    fi

    # Ensure all files are committed in $repo_name
    (
        cd "$repo_name" || return 1
        if ! git diff --quiet; then
            echo "Uncommitted changes found in '$repo_name'. Please commit all changes before proceeding."
            return 1
        fi
    )

    # Clone as bare repository
    if ! git clone --bare "$1" "$repo_name.git"; then
        echo "Cloning failed. Please check the repository path."
        return 1
    fi

    # Secure copy to remote server
    if ! scp -r "$repo_name.git" git:git; then
        echo "Failed to copy repository to remote server."
        return 1
    fi

    # clone it
    git clone "git.failmode.com_m:git/${repo_name}" "${repo_name}.cloned-from-remote"

    # Move old repo
    mv "${repo_name}" "${repo_name}.cloned_to_remote"

    # Move new repo
    mv "${repo_name}.cloned-from-remote" "${repo_name}"

    echo "Repository '$repo_name.git' successfully cloned, copied to remote server and cloned back."
}



