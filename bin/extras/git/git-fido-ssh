#!/usr/bin/env bash
#
# git-fido-ssh - Sets up an SSH key, checks and switches GitHub account,
#                adds the key to GitHub, configures it for Git signing,
#                updates Git user details based on realm, and manages SSH configurations.
#
# Usage: ./git-fido-ssh keyid@realm [git-email] [git-name]
# 
#       keyid: Any word to identify your Yubikey to you (e.g. key1)
#       realm: security domain (e.g. github account)
#
# Recommendations:
#
# Use a separate github account for each security domain:
# - e.g. personal, work, mycompany, etc
# - SSO Authorisation not required for FIDO SSH?
# - When running, only authenticate to github.com accounts from machines within that security domain.

#
# Prerequisites:
#
# - GitHub CLI (gh) - https://cli.github.com/
#
# Preparation for WSL (Windows Subsystem for Linux)
# --------------------------------------------------
# WSL does not support USB devices natively, so we need to use Windows OpenSSH to access the YubiKey.
# This requires a recent version of OpenSSH for Windows and a helper program to access the YubiKey.
#
# Download and install a recent version of OpenSSH for Windows. This will give you 'ssh-sk-helper.exe'
# 1. Download and install a recent OpenSSH for Windows:
#      OpenSSH for Windows: https://github.com/PowerShell/Win32-OpenSSH/releases
# 2. Tell WSL OpenSSH to ask Windows for help:
#
#      echo 'export SSH_SK_HELPER="/mnt/c/Program Files/OpenSSH/ssh-sk-helper.exe"' >> ~/.bashrc

# TODO
#
# - work out SSO issue
# - Refuse to create key if yubikey does not have pin set
# - resident or not
# - Print whenever we do something




create-key() {
    if [[ -z "$keyid" || -z "$realm" ]]; then
        echo "Error: Invalid format. Please use keyid@realm."
        return 1
    fi
    
    echo "Generating SSH key for $keyid_realm"
    echo "Note: Please ensure your YubiKey is configured with a PIN for enhanced security."
    ssh-keygen -t ecdsa-sk -b 521 -C "${keyid_realm}" -f "$key_path"
    symlink_path="$(dirname $key_path)/${keyid_realm}"
    echo "SSH key generated at $key_path"

    echo "Creating symlink: ${key_path} -> ${realm}"
    echo "This is so SSH config can use the key based on the realm."
    echo "This allows us to use the same ssh config on multiple machines with their own Yubikey"
    echo "Don't use the symlink on a spare key if you use a resident yubikey on this machine."
    echo
    symlink_target="$(dirname $key_path)/${realm}"
    if [[ -f $symlink_target ]]; then
        # confirm whether user wants to overwrite the symlink
        echo "Symlink already exists: $(ls -la "${symlink_target}")"
        read -p "Do you want to overwrite the existing symlink? (y/n) " choice
        [[ $choice =~ ^[Yy]$ ]] || return 1
    fi
    (cd $(dirname $key_path) && ln -sf "$keyid_realm" "${realm}")
}

configure-ssh() {
    mkdir -p "$(dirname $ssh_config_file)"
    temp_file="$(mktemp)"
    echo "Host $realm" > "$temp_file"
    echo "  User git" >> "$temp_file"
    echo "  HostName github.com" >> "$temp_file"
    echo "  IdentityFile $key_path" >> "$temp_file"
    echo "  IdentitiesOnly yes" >> "$temp_file"
    mv "$temp_file" "$ssh_config_file"

    # Include the new SSH configuration in the main SSH config file
    local include_str="Include config.d/*"

    # Check if the line already exists
    local config_file="$HOME/.ssh/config"
    grep -qxF "$include_str" "$config_file" || {
        # Prepend the line to a temp file
        temp_file="$(mktemp)"
        echo "$include_str" > "$temp_file"
        # Append the original file content to the temp file
        cat "$config_file" >> "$temp_file"
        # Move the temp file to the original file location
        cp "$config_file" "$config_file.$(date +%s).bak"
        mv "$temp_file" "$config_file"
    }
}

configure-git() {

    if [[ -f "$git_config_path" ]]; then
        local existing_email=$(git config -f "$git_config_path" --get user.email)
        local existing_name=$(git config -f "$git_config_path" --get user.name)

        if [[ -n "$git_email" && "$git_email" != "$existing_email" ]]; then
            read -p "Replace existing email $existing_email with $git_email? (y/n) " choice
            [[ $choice =~ ^[Yy]$ ]] && git config -f "$git_config_path" user.email "$git_email"
        fi

        if [[ -n "$git_name" && "$git_name" != "$existing_name" ]]; then
            read -p "Replace existing name $existing_name with $git_name? (y/n) " choice
            [[ $choice =~ ^[Yy]$ ]] && git config -f "$git_config_path" user.name "$git_name"
        fi
    else
        echo "[user]" > "$git_config_path"
        [[ -n "$git_email" ]] && echo "email = $git_email" >> "$git_config_path"
        [[ -n "$git_name" ]] && echo "name = $git_name" >> "$git_config_path"
        echo "signingkey = $(cat "${key_path}.pub")" >> "$git_config_path"
        git config --global --add includeIf."gitdir:~/projects/${realm}/".path "$git_config_path"
    fi
}

configure-github() {

    echo "Your newly created publich SSH key needs to be uploaded (twice) to Github:"
    echo
    echo " - authentication"
    echo " - signing"
    echo 
    echo "This script can do that using the GitHub CLI (gh) or you can do it manually"
    echo
    read -p "Proceed with uploading public key to GitHub using Github CLI? (y/n) " choice
    [[ $choice =~ ^[Yy]$ ]] || return 1

    if github-login; then
        # Add ssh-key and signing-key
        echo "Adding SSH key to GitHub"
        gh ssh-key add --type authentication --title "${keyid_realm}" "${key_path}.pub"
        echo "Adding signing key to GitHub"
        gh ssh-key add --type signing --title "${keyid_realm}" "${key_path}.pub"
        echo
        echo "Logging out of GitHub"
        gh auth logout
    fi
}

github-login() {
    echo "Logging in to GitHub (via GitHub CLI OAuth2 Device Flow) with the following scopes:"
    echo
    echo "- admin:public_key"
    echo "- admin:signing_key"
    echo
    echo "Do this only on a device you trust with this access."
    echo
    echo "If your default browser does not support GitHub Login (e.g., Firefox may not handle Microsoft SSO with Security Keys), please open the following URL in one that does: https://github.com/login/device"

    gh auth status 2>&1 | grep 'Logged in to github.com as'
    gh auth login --web --git-protocol https --scopes admin:public_key,admin:ssh_signing_key
}

git-fido-ssh() {
    local keyid_realm="$1"
    local git_email="$2"
    local git_name="$3"

    local keyid="${keyid_realm%@*}"
    local realm="${keyid_realm#*@}"
    local key_path="$HOME/.ssh/${keyid_realm}"
    local git_config_path="$HOME/.gitconfig_${realm}"
    local ssh_config_file="$HOME/.ssh/config.d/${realm}"

    create-key
    eval "$(ssh-agent -s)"
    ssh-add "$key_path"
    configure-ssh
    configure-git
    configure-github

    echo "Setup complete for key: $keyid_realm"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    if [[ $# -lt 1 ]]; then
        echo "Usage: $0 keyid@realm [git-email] [git-name]"
        exit 1
    fi

    git-fido-ssh "$@"
fi
